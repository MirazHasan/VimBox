" ================================================
"         .__           ___.
"  ___  __|__|  _____   \_ |__    ____  ___  ___
"  \  \/ /|  | /     \   | __ \  /  _ \ \  \/  /
"   \   / |  ||  Y Y  \  | \_\ \(  <_> ) >    <
"    \_/  |__||__|_|  /  |___  / \____/ /__/\_ \
"                   \/       \/               \/
" ================================================
"
"
" See `README.md` for features and shortcuts
" Additional features not mentioned in README:
"
" Spell Check:
" Command+shift+p to toggle spell check on comments (underlines in red).
"
" Mac ProTips:
"  To further improve the text rendering on Mac OSX:
"  1. From the shell: defaults write org.vim.MacVim MMCellWidthMultiplier 0.9
"  2. Opens all files from other apps in vert split defaults write
"  org.vim.MacVim MMVerticalSplit YES
"  3. If when changing monitors, your fonts go from nice and thin to ugly and
"  bold: This should fix it:
"   Textmate disables font smoothing only for dark backgrounds, but MacVim
"   only has a global setting. If you use dark backgrounds consider disabling.
"   https://stackoverflow.com/questions/24598390/macvim-thicker-font-rendering-compared-to-textmate
"   defaults write org.vim.MacVim AppleFontSmoothing -int 0
"  4. Speed up full screen transition:
"  defaults write org.vim.MacVim MMFullScreenFadeTime 0.05
"
" Cygwin:
" Tested and should work. AutoHotkey exist that provide an identical experience
" to the Mac OSX experience.
"
" Bundle System:
" =================================================================
" Uses the VimPlug system. Add bundles to ~/.vim/bundlesVimRc with:
" Plug "githubUser/repo"
" Open a new window and then run `:PlugInstall`
" Close and then reopen the vim window.

" Performance Profiling:
" ========================
" http://stackoverflow.com/questions/12213597/how-to-see-which-plugins-are-making-vim-slow
"
" Find Slow Plugins During Actions:
" =================================
"
"   :profile start profile.log
"   :profile func *
"   :profile file *
"   " At this point do slow actions
"   :profile pause
"   :noautocmd qall!
"
" Profile Startup Time:
" ==================================================================
"   mvim --startuptime ~/.vim/timeCost.txt ~/.vim/timeCost.txt
"
" Debugging VimSript Errors:
" ==================================================================
" Ever have this happen to you?
"
"    Error <SNR>49_Destroy[10]...Line 3
"
" This is Vim's idea of a good error message (when one of your plugin throws
" an error). See that weird <SNR>49? That's the script number which is
" assigned to the VimScript file behind the scenes (invisibly to you) - Here's
" how you find out which script that is. Execute :scriptnames and find the
" corresponding number in that list.  So <SNR>49 means script number 49, and
" Destroy, UnsetIMap are the last two functions in the stack trace (so the
" problem is ultimately in UnsetIMap in my case).  And that "line 3"?  That's
" not the line number in the file like any reasonable error message would
" display that's the line number within the deepest function.

" Seeing Who Is Setting A Setting:
" =================================================================
" :verbose set settingName?

" Using In Terminal
" ================
" Using VimBox in your terminal is semi-supported. It should work, but it is
" not tested often. If you see something off, please report but a PR is
" the best way to move VimBox forward with terminal support.
"
" Note: If you use iTerm, and you want airline symbols to show up correctly
" you must change the font in *two* places in iTerm. The normal font, and the
" non-ascii font!
"
" Remote Editing:
"
" - Speed up performance at the network layer:
"   http://thomer.com/howtos/netrw_ssh.html
" - Help netrw-passwd
"
" - Also good suggestions here: https://stackoverflow.com/questions/28795721/how-to-save-in-vim-a-remote-file-asynchronously
"   - As always disable airline/lightline vcs integration.
" - https://github.com/eshion/vim-sync/
" - https://github.com/grantm/bcvi
" - https://github.com/seletskiy/vim-refugi

" if v:version < 799
  " echomsg "VimBox works best with Vim8 or newer. Please upgrade your Vim/MacVim"
" endif

" TODO: This entire file should/could be ejected into the generated Vimrc.

let s:useSettingsSystem = 1

let g:vimBoxIsLoading = 1

let skipGeneration = 0

" Find Location Of VimBox Installation:
" =====================================
" From: https://stackoverflow.com/questions/4976776/how-to-get-path-to-the-current-vimscript-being-executed
" Symlink Resolved Location Of VimBox Installation: (Won't Always Be .vim!):
let g:vimBoxInitialVimRcPath = resolve(expand('<sfile>:p'))
let g:vimBoxInstallationRoot = fnamemodify(g:vimBoxInitialVimRcPath, ':h')

" Source The Utilities That Help Us Bootstrap The Startup:
" ========================================================
" For some reason these have to be manually sourced even if we only used their contents after plug#end
" Any functions used in the startup process, even if we've executed plug#end.
" We first need to manually source this one file which defines all the path utilities.
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBoxUtils.vim"
" Now go ensure there's a slash on the root using the utilities.
let g:vimBoxInstallationRoot = EnsureSlash(fnamemodify(g:vimBoxInitialVimRcPath, ':h'))
let g:vimBoxStockPluginsDir = PathJoinDir(PathJoinDir(g:vimBoxInstallationRoot, 'dotVim'), 'localBundle')
" VimBox Comes With One Stock Plugin For VimBox: Called the vim-box plugin.
" For some reason these have to be manually sourced even if we only used their contents after plug#end
" Any functions used in the startup process, even if we've executed plug#end.
" We first need to manually source this one file which defines all the path utilities.
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBoxUtils.vim"
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBoxMessage.vim"
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBoxConfig.vim"
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBox.vim"
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBoxGeneratedRc.vim"


" We will follow the XDG Spec as NeoVim Does:
" https://github.com/neovim/neovim/issues/78
" https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
" Cache:
"     ~/.cache/vim-box/
" Data: Undo/backup files.
"     ~/.local/share/vim-box/
" User Config:
"     ~/.config/vim-box/
let g:vimBoxSettingsDefault = PathJoinFile(PathJoinDir(g:vimBoxStockPluginsDir, 'vim-box'), 'settings.json')

" Location Of Home Directory:
let g:vimBoxHomeDir = $HOME . _VimBoxSlashFor( $HOME )

" Some XDG Defaults:
let g:vimBoxDefaultCacheDir = PathJoinDir(g:vimBoxHomeDir, '.cache')
let g:vimBoxDefaultDataDir = PathJoinDir(PathJoinDir(g:vimBoxHomeDir, '.local'), 'share')
let g:vimBoxDefaultConfigDir = PathJoinDir(g:vimBoxHomeDir, '.config')

" Where Cache Files Should Be Stored: (Default $HOME/.cache):
let g:vimBoxXdgCacheDir = exists('$XDG_CACHE_HOME') ? PathJoinDir($XDG_CACHE_HOME, 'vim-box') : PathJoinDir(g:vimBoxDefaultCacheDir, 'vim-box')
" Where User Specific Data Files Should Be Written: (undo/backup files) (Default $HOME/.local/share):
let g:vimBoxXdgDataDir = exists('$XDG_DATA_HOME') ? PathJoinDir($XDG_DATA_HOME, 'vim-box') : PathJoinDir(g:vimBoxDefaultDataDir, 'vim-box')
" Where User Specific Configuration Should Be Stored: (Default $HOME/.config)
let g:vimBoxXdgConfigDir = exists('$XDG_CONFIG_HOME') ? PathJoinDir($XDG_CONFIG_HOME, 'vim-box') : PathJoinDir(g:vimBoxDefaultConfigDir, 'vim-box')

" TODO: This should be sourced from the location of current vim script so that
" you can use VimBox without having to install it over your old vim install.
let g:vimBoxUndoDir = PathJoinDir(g:vimBoxXdgDataDir, 'undo')
let g:vimBoxSessionDir = PathJoinDir(g:vimBoxXdgDataDir, 'vim_sessions')
let g:vimBoxLogsDir = PathJoinDir(g:vimBoxXdgDataDir, 'logs')
let g:vimBoxPluginInstallDir = PathJoinFile(g:vimBoxXdgDataDir, 'bundle')
if !isdirectory(g:vimBoxUndoDir)
  call mkdir(g:vimBoxUndoDir, "p")
endif
if !isdirectory(g:vimBoxSessionDir)
  call mkdir(g:vimBoxSessionDir, "p")
endif
if !isdirectory(g:vimBoxLogsDir)
  call mkdir(g:vimBoxLogsDir, "p")
endif
let g:vimBoxLogsCurrentSession = PathJoinFile(g:vimBoxLogsDir, strftime("%F"))
" The automatically generated vimrc file based on config. Useful for reproing
" and sharing.
let g:vimBoxGeneratedRc = PathJoinFile(g:vimBoxXdgCacheDir, ".generated.vimrc")
let g:vimBoxErrorsDuringLoad = 0

" In Vim-box, the user customizes vim by making a "user" plugin which is in
" the simplest form, just an settings.json file, but can include directories
" like:
" plugin/
" autoload/
" ftdetect/
let g:vimBoxUserPluginDir = PathJoinDir(g:vimBoxXdgConfigDir, 'user')
let g:vimBoxUserSettings = PathJoinFile(g:vimBoxUserPluginDir, 'settings.json')
" Sourced after vimbox does all the deafult behavior.
" Maybe the user init file should actualy be the one to source.
let g:vimBoxUserInit = PathJoinFile(g:vimBoxUserPluginDir, 'vimBoxUserInit.vim')
" See .gvimrc
let g:vimBoxUserGVimInit = PathJoinFile(g:vimBoxUserPluginDir, 'vimBoxUserGVimInit.vim')

if !isdirectory(g:vimBoxXdgConfigDir)
  call mkdir(g:vimBoxXdgConfigDir, "p")
endif
if !isdirectory(g:vimBoxUserPluginDir)
  call mkdir(g:vimBoxUserPluginDir, "p")
endif

if has('gui_win32')
  set rtp+=~/.vim
endif

if has('vim_starting')
   if &compatible
     set nocompatible               " Be iMproved
   endif
endif

" There's a huge circular dependency.  User config defines disabled plugins
" and installed plugins.  We need those plugins to be loaded before knowing
" the full runtime path to grab all config from. But we only have the ability
" to load all config from the runtime path. So we first load all the config
" when the runtime path only consists of user plugin. Then generate the plugin
" loader code. Then source it (which puts them all in the runtime path). Then
" we regenerate the config, and call the configure hook in that.
" The User is none the wiser. It's a little slower though, so we should avoid
" doing any computation unless config files changed.'
call VimBoxLog('INIT', "Initializing New VimBox Session via home directory vimrc")
" Load all the stock plugins that we use in the process of doing all the
" other plugin/settings loading.
let &runtimepath=&runtimepath . ',' .  PathJoinDir(g:vimBoxStockPluginsDir, 'vim-plug')
let &runtimepath=&runtimepath . ',' .  PathJoinDir(g:vimBoxStockPluginsDir, 'json-ponyfill.vim')
let &runtimepath=&runtimepath . ',' .  PathJoinDir(g:vimBoxStockPluginsDir, 'color-tools')
let &runtimepath=&runtimepath . ',' .  PathJoinDir(g:vimBoxStockPluginsDir, 'vim-box')

if !skipGeneration
  call VimBoxInitConfigs()
  " The generated VimRc defines one __VimBoxGeneratedPlugCalls() which calls
  " Plug for all the configured plugins. We will
  call VimBoxGenerateVimRc()
endif
execute "source " . g:vimBoxGeneratedRc

silent! call plug#begin(g:vimBoxPluginInstallDir)
" Add the special "user plugin" TODO: Allow for a user-before plugin as well
if exists("*__VimBoxGeneratedConfigure_disabler_ForScope_")
  call __VimBoxGeneratedConfigure_disabler_ForScope_()
endif
call __VimBoxGeneratedPlugCalls()
call plug#end()


" Disable visualbell by default
" http://unix.stackexchange.com/a/5313
set visualbell
" This actually needs to be set in .gvimrc for gui forms
set t_vb=

try
  set shortmess+=filmnrxoOtTc
catch /E539: Illegal character/
  " Some versions do not like c
  set shortmess+=filmnrxoOtT
endtry
try
  set switchbuf+=useopen,usetab,vsplit
catch /E474: Invalid argument/
  set switchbuf+=useopen,usetab
endtry
" Disable Vim's startup screen
set shortmess+=I

" MacVim Quick Start is pretty strange. It's as if it always opens the *next*
" MacVim window whenever you open the currently visible one.
" So this prompt applies to the *next* window you'll open typically - in that
" case.
" Notice the ! not
if !len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
  " Now reconfigure now that plugins are all in the runtimepath and we can
  " actually see their included settings.json files.
  if !skipGeneration
    call VimBoxInitConfigs()
    call VimBoxGenerateVimRc()
  endif
  execute "source " . g:vimBoxGeneratedRc
  call __VimBoxGeneratedConfigureForScope_()
  " Some vim reset plugin screws up listchars
  set listchars = "eol:$"
else
  " Don't show statusline when airline might not be loaded or configured.
  if exists("g:gui_oni") || has('gui') && has('mac') && has('gui_running')
    set background=dark
    colorscheme taste
    set guioptions-=r
    set guioptions-=R
    set guioptions-=l
    set guioptions-=L
    " The backticks and echo make it work better in terminal env
    autocmd VimEnter *
      \  if len(filter(values(g:plugs), '!isdirectory(v:val.dir)')) && 1==confirm("Download and Install Plugins?", "&Yes\n&No", 1)
      \|   set laststatus=0
      \|   PlugInstall --sync | echomsg "Open a new window to enjoy the plugins!" | let xx=confirm("Open a New Window For Plugins to Take Effect.")
      \| endif
    " Source the settings just in case they respond with "No, don't update plugins"
    " Now reconfigure now that plugins are all in the runtimepath and we can
    " actually see their included settings.json files.
    if !skipGeneration
      call VimBoxInitConfigs()
      call VimBoxGenerateVimRc()
    endif
    execute "source " . g:vimBoxGeneratedRc
    call __VimBoxGeneratedConfigureForScope_()
    " Some vim reset plugin screws up listchars
    set listchars = "eol:$"
  else
    set laststatus=0
    echomsg "Attempting to install plugins. Be patient. Vim is working in the background. It will start eventually."
    PlugInstall --sync
    " Now reconfigure now that plugins are all in the runtimepath and we can
    " actually see their included settings.json files.
    if !skipGeneration
      call VimBoxInitConfigs()
      call VimBoxGenerateVimRc()
    endif
    execute "source " . g:vimBoxGeneratedRc
    call __VimBoxGeneratedConfigureForScope_()
    " Some vim reset plugin screws up listchars
    set listchars = "eol:$"
  endif
endif

if file_readable(g:vimBoxUserInit)
  execute "source " . g:vimBoxUserInit
endif
let g:vimBoxIsLoading = 0
